# javascript代码构建总结
## 基本封装：

- 使用组合继承，实例属性于构造函数内，通用方法于原型内
- 对代码进行抽象，避免代码重复，且抽离基于CSS的选择器字符串等对样式或DOM操作的值，便于后期维护
- 方法过长时，考虑拆分方法，把能够分离的过程进一步抽象
- 通用方法可做进一步抽离
- 在绑定多个事件时，可以在constructorF（构造函数）中指定this.eventMaps对象，其中包含了多个事件的方法名，便于维护查找
- 基于该形式构建的代码可进一步抽离，实现OOP，模块化
- 封装的对象或类的内部定义一个初始化方法init，并且可以在自执行代码块中对global暴露一个接口，避免全局污染，遵循封装原则
```javascript
(function(arguments){
    'use strict';
    var constructorF=function(){
        //这里定实例通用值
    }
    constructorF.Eles={   //构造函数定义属性，在原型中的方法用到的选择器使用该属性中的值，便于维护
        key:'selector',     
        key2:'selector2' 
    }

    var utils={
        do:function() {}	//这里的函数是从ConstructorF.prototype某些方法中抽离出来的函数，可以直接在原型中用utils.函数名（值）来调用，减少代码量，增加可读性
    }

    ConstructorF.prototype={
        //这里写方法(完全和功能有关的方法)
    }

    Global.functionAPI=func; //这里向外暴露接口
    Window.onload(
        new constructorF()  // 加载后创建实例
    )
})(arguments)
````

## 常见js业务场景分析以及解决思路
1.	选择器滥用
2.	事件绑定滥用
3.	生命周期混乱，没概念
4.	复用性和沙盒安全
5.	模板渲染技巧

## 解耦业务js代码，如何在业务中使用设计模式
1.	模块化和继承到底怎么用
2.	拆分维度问题和作用域传递
3.	找到utils，拒绝ctrl+c/v

## 常见的一些业务优化方法总结
1.	判断太多怎么办
2.	Dom操作到底怎么做才是最好的，找到最优解
3.	样式该怎么加

## 增加项目可维护性和代码的可读性
1.	注释真的好吗？
2.	格式化问题
3.	写代码要说人话


先考虑业务逻辑，把业务逻辑写成伪代码，完成业务逻辑后再填空，补充完成各个函数功能
